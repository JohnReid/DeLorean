---
title: Fit low-rank branching model to Guo data
author: John Reid
output: pdf_document
---

```{r build, echo=FALSE, eval=FALSE}
devtools::load_all()
rmarkdown::render('Guo-branching-lowrank.Rmd')
```


Load libraries
```{r loadLibs, message=FALSE}
library(stringr)
library(dplyr)
library(reshape2)
library(ggplot2)
library(ggthemes)
library(DeLorean)
```


```{r config, echo=FALSE, message=FALSE}
#
# Seed RNG
set.seed(1)
#
# Configure ggplot2
theme_set(theme_few())
scale_colour_discrete <- function(...) scale_colour_few(...)
scale_fill_discrete <- function(...) scale_fill_few(...)
#
# Configuration for knitr and rmarkdown
library(knitr)
library(rmarkdown)
#
# knitr options
opts_chunk$set(
  fig.path = 'figures/Guo-rand-',
  stop_on_error = TRUE,
  fig.width = 12.5,
  fig.height = 8)
#
# Widths for saving figures
text.width <- 4.79  # LaTeX width in inches
golden.ratio <- 1.618  # Pleasing ratio
fig.width <- text.width
fig.height <- text.width / golden.ratio
#
# Stylesheet
options(
  markdown.HTML.stylesheet = system.file("inst/Rmd/foghorn.css", package="DeLorean"))
font.family <- "Verdana"
font.theme <- theme_update(text=element_text(family=font.family))
theme_set(font.theme)
#
# Create directory for plots and list to store them
dir.create('Plots')
plots <- list()
```


# Load data
Load the data from the `DeLorean` package.
```{r load.test.data}
data(GuoDeLorean)
guo.expr.centred <- t(scale(t(guo.expr), scale=FALSE, center=TRUE))
guo.cell.meta <-
  guo.cell.meta %>%
  mutate(cell.type = factor(ifelse(is.na(cell.type), "NA", as.character(cell.type))))
```


# Fit DeLorean model

Create DeLorean object.
```{r createDL}
dl <- de.lorean(
  guo.expr.centred,
  guo.gene.meta,
  guo.cell.meta)
```

## PCA
Perform a PCA on the expression data and calculate which direction in PC1-PC2 space best
correlates with capture time.
```{r pcaPkg}
dl <- pca.expr(dl)
```

Project the cells onto PC1 and PC2. Show the direction that best reflects capture time.
```{r}
plots$PCA <-
  ggplot(dl$pca.df, aes(x = PC1, y = PC2, label = cell, colour = capture, shape = cell.type)) +
  geom_point(size = 4) +
  geom_abline(slope = dl$capturetime.slope)
plots$PCA
```

Project the cells onto PC1 and PC2 coloured by the z estimates
```{r}
plots[['PCA-z']] <-
  ggplot(dl$pca.df, aes(x = PC1, y = PC2, colour = z.hat)) +
  geom_point(size = 4) +
  geom_abline(slope = dl$capturetime.slope) +
  scale_colour_gradient2()
plots[['PCA-z']]
```


## Estimate hyperparameters
```{r empiricalBayes}
model.name <- 'branching'
dl <- estimate.hyper(dl, sigma.tau = .25, model.name = model.name, adjust.cell.sizes = FALSE)
```

Choose a few cells from each capture time
```{r chooseCells}
guo.cell.meta %>%
  group_by(capture) %>%
  summarise(number = n())
filter.cells <- TRUE
if (filter.cells) {
  # n.sample <- 157
  n.sample <- 17
  sampled.cells <- guo.cell.meta %>%
    group_by(capture) %>%
    do(sample_n(., min(nrow(.), n.sample)))
  sampled.cells %>% summarise(number = n())
  dl <- filter.cells(dl, cells=sampled.cells$cell)
}
```

## Fit
```{r fit}
dl <- prepare.for.stan(dl)
dl <- compile.model(dl)
dl <- fit.model(dl, method = 'vb', num.cores = 1)
dl <- process.posterior(dl)
dl <- analyse.noise.levels(dl)
```

```{r shinyStan, eval = FALSE, echo = FALSE}
#
# Examine with ShinyStan
#
my_sso <- shinystan::launch_shinystan(fit)
```


Calculate best sample estimates for tau and z
```{r tauVsZ}
init.df <-
  data.frame(
    c = 1:dl$stan.data$C,
    tau.init = init$tauoffset + dl$stan.data$time,
    z.init = init$z)
tau.z <- with(best.m, left_join(tau, z) %>% left_join(dl$cell.map))
```

Plot tau vs. z from the best sample.
The line segments show where they were initialised at the start of inference.
```{r plotTauZ}
plots[['tau.z']] <-
  ggplot(tau.z, aes(x = tau, y = z, color = capture, shape = cell.type)) +
  geom_point(size = 4) +
  geom_segment(
    data = left_join(tau.z, init.df),
    mapping = aes(x = tau.init, xend = tau, y = z.init, yend = z),
    alpha = .2)
plots[['tau.z']]
```

Calculate the posterior for the noise and temporal variance levels
```{r postNoise}
var.post.stats <-
  with(samples.m, left_join(psi, omega)) %>%
  group_by(g) %>%
  summarise(
    psi.mean   = mean(psi),
    psi.sd     = sd(psi),
    omega.mean = mean(omega),
    omega.sd   = sd(omega)) %>%
  left_join(dl$gene.map)
sample_n(var.post.stats, 10)
plots$var <-
  ggplot(var.post.stats,
         aes(x = psi.mean, xmin = psi.mean - psi.sd, xmax = psi.mean + psi.sd,
             y = omega.mean, ymin = omega.mean - omega.sd, ymax = omega.mean + omega.sd,
             label = gene)) +
  geom_point(alpha = .4) +
  geom_errorbar(alpha = .4) +
  geom_errorbarh(alpha = .4) +
  geom_label(alpha = .8)
```

Plot the posterior for the noise and temporal variance levels
```{r plotVarPost}
plots$var
```


## Calculate distances between cells

We want to know if there are any cells that are significantly further away
from their closest neighbours in latent-space compared to gene-space.
```{r calcDists}
dists.gene <- as.matrix(dist(t(dl$expr)))
dists.gene <- dists.gene / mean(dists.gene)
latent <- as.matrix(select(tau.z, tau, z))
dists.latent <- as.matrix(dist(latent))
dists.latent <- dists.gene / mean(dists.latent)
qplot(as.vector(dists.gene))
dists.weighted <- exp(-dists.gene**2 / .7**2) * dists.latent / dists.gene
diag(dists.weighted) <- 0
plots[['rel.dists']] <-
  ggplot(
    mutate(tau.z, weighted.dist = rowSums(dists.weighted)),
    aes(x = tau, y = z, color = weighted.dist, shape = cell.type)) +
  geom_point(size = 4)
plots[['rel.dists']]
```


## Predicted expression

Calculate the predicted mean and variances on a grid across the latent space.
```{r calcPost}
#
# Expose Stan functions
stan.fns <- rstan::expose_stan_functions(fit)
#
# Get range for grid
tau.range <- range(best.m$tau$tau)
tau.min <- floor(tau.range[1])
tau.max <- ceiling(tau.range[2])
tau.grid <- seq(from = tau.min, to = tau.max, length.out = 51)
tau.step <- tau.grid[2] - tau.grid[1]
z.range <- range(best.m$z$z)
z.min <- floor(z.range[1])
z.max <- ceiling(z.range[2])
z.grid <- seq(from = z.min, to = z.max, length.out = 51)
z.step <- z.grid[2] - z.grid[1]
#
# Expand into grid
grid.df <- expand.grid(tau = tau.grid, z = z.grid)
grid <- t(as.matrix(grid.df))
class(grid)
dim(grid)
#
# Covariance across grid points
K.grid <- cov_symmetric(grid, dl$stan.data$lengthscales)
class(K.grid)
dim(K.grid)
#
# Covariance across latent points from posterior
cell.post <- with(best.m, left_join(tau, z))
points.post <- t(as.matrix(select(cell.post, tau, z)))
K.post <- cov_symmetric(points.post, dl$stan.data$lengthscales)
dim(K.post)
#
# Cross-covariance
K.cross <- cov(points.post, grid, dl$stan.data$lengthscales)
dim(K.cross)
```

Calculate the predicted expression for randomly selected genes across the latent space.
```{r predictExpr}
calc.post <- function(row) {
  message(row$gene)
  y <- dl$expr[row$g,]
  psi <- row$psi
  omega <- row$omega
  gp.post <- gp.predict(
    y - mean(y),
    psi * K.post + diag(omega, nrow = nrow(K.post)),
    psi * K.cross,
    psi * K.grid + diag(omega, nrow = nrow(K.grid)))
  grid.df %>%
    mutate(
      # g = row$g,
      # gene = row$gene,
      expr.post = as.vector(gp.post$mu))
}
genes.df <- with(best.m, left_join(psi, omega) %>% left_join(dl$gene.map))
all.post <-
  genes.df %>%
  sample_n(9) %>%
  group_by(g) %>%
  do(calc.post(.)) %>%
  ungroup() %>%
  left_join(dl$gene.map)
plots$gex <-
  ggplot(all.post,
         aes(x = tau, y = z, fill = expr.post)) +
  geom_tile(width = tau.step, height = z.step) +
  scale_fill_gradient2(low = scales::muted("blue"), mid = "white", high = scales::muted("red")) +
  geom_point(data = tau.z %>% mutate(expr.post = 0),
             mapping = aes(x = tau, y = z, shape = cell.type),
             size = 2) +
  facet_wrap(~ gene)
```

Plot the posterior mean of the expression levels for randomly selected genes across the latent space.
```{r plotGex}
plots$gex
```


```{r savePlots, echo = FALSE}
save_plot <- function(name) {
  filename <- str_c('Plots/Guo-', name, '.pdf')
  message('Saving: ', filename)
  ggsave(
    filename,
    plots[[name]],
    width = 12,
    height = 8,
    units = 'in')
  filename
}
invisible(lapply(names(plots), save_plot))
```


# Session information

R version and packages used:
```{r Rversion}
date()
devtools::session_info()
```
