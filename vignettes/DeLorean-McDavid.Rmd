```{r build, echo=FALSE, eval=FALSE}
library(devtools)
load_all('..')
library(rmarkdown)
render('DeLorean-McDavid.Rmd')

```

---
title: DeLorean analysis of McDavid et al. cell cycle data
author: John Reid
bibliography: DeLorean.bib
output: html_document
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{DeLorean analysis of McDavid et al. cell cycle data}
-->


```{r config, echo=FALSE, message=FALSE}
library(knitr)
library(knitcitations)
library(rmarkdown)
#
# knitr options
#
opts_chunk$set(
    fig.path = 'figures/McDavid-',
    stop_on_error = TRUE,
    fig.width = 12.5,
    fig.height = 8)
#
# Citations
#
cleanbib()
cite_options(
    # hyperlink = 'to.doc',
    hyperlink = TRUE,
    # style = 'html',
    # citation_format = 'text',
    citation_format = "pandoc",
    cite.style = "numeric",
    check.entries = TRUE)
    # hyperlink = TRUE)
bib <- read.bibtex("DeLorean.bib")

```

```{r init, echo=FALSE, message=FALSE, warning=FALSE}
# suppressMessages(loadfonts())
library(DeLorean)
#
# Stylesheet
#
options(markdown.HTML.stylesheet = system.file("inst/Rmd/foghorn.css",
                                               package="DeLorean"))
font.family <- "Verdana"
font.theme <- theme_update(text=element_text(family=font.family))
theme_set(font.theme)

```


`r citet(bib[["mcdavid_modeling_2014"]])` assayed actively cycling single
cells in order to examine the confounding effect of the cell cycle on
single cell expression analyses. They measured the expression of 333 genes
in 930 cells across three cell cycle phases and three cell lines.


# Data

McDavid et al.'s data is available in the `DeLorean` R package. Not all 333
genes are represented as several are rarely expressed.
```{r loadLib}
library(DeLorean)
data(McDavidDeLorean)
dl <- de.lorean(
    mcdavid.expr,
    mcdavid.gene.meta,
    mcdavid.cell.meta)

```

```{r child=report.file("data")}
```



# Estimate hyperparameters

Examine data for empirical Bayes estimation of hyperparameters.
```{r empiricalBayes}
dl <- estimate.hyper(
    dl,
    sigma.tau=.5,
    delta=.5)

```

```{r child=report.file("hyper-parameters")}
```


# Choose genes and cells

Choose a few cells from the PC3 cell line.
```{r filterCells}
set.seed(1)
max.cells <- 117
cells.PC3 <- sample(filter(mcdavid.cell.meta, "PC3" == cellline)$cell,
                    max.cells)
cell.filter <- function(cells) cells %in% cells.PC3
dl <- filter.cells(dl, cell.filter)

```


Choose a handful of genes with low $p$-values from the McDavid et al.
differential expression test.
```{r filterGenes}
use.highest.rank.genes <- TRUE
if (use.highest.rank.genes) {
    max.rank <- 147
    genes.for.stan <- (filter(mcdavid.gene.meta,
                                    ! is.na(cbRank),
                                    cbRank < max.rank + 1)
                    %>% arrange(cbRank))$gene
} else {
    # Just use so many random genes
    max.genes <- 23
    genes.for.stan <- sample((filter(mcdavid.gene.meta,
                                    pvalue > 5)
                            %>% arrange(cbRank))$gene,
                            max.genes)
}
gene.filter <- function(genes) genes %in% genes.for.stan
dl <- filter.genes(dl, gene.filter)

```


# Compile and fit model

Define and compile the model, find the best initialisation, and fit the model.
```{r model}
load_all('..')
dl <- format.for.stan(dl, period=3, hold.out=3)
dl <- compile.model.simple(dl)
dl <- find.best.tau(dl)
system.time(dl <- fit.model(dl))

```


# Examine convergence.

```{r examConv}
dl <- examine.convergence(dl)

```

```{r child=report.file("convergence")}
```



# Analyse posterior

Examine posterior.
```{r posterior}
dl <- process.posterior(dl)
dl <- analyse.noise.levels(dl)

```

```{r child=report.file("posterior")}
```


# Profiles

Calculate expression profiles.
```{r makePredictions}
dl <- make.predictions(dl)
```

```{r child=report.file("profiles")}
```


# Examine peak times

```{r peakTimes}

# Plot cbPeaktime against best sample max predicted mean time
print(plot.best.predictions(dl, genes="CDCA8"))
dl <- within(dl, {
    peak.vs.max <- (best.mean
        %>% group_by(g)
        %>% summarise(predicted.peak=tau[which.max(predictedmean)])
        %>% left_join(gene.map))
    peak.max.cor <- with(peak.vs.max, { cor(cbPeaktime, predicted.peak, use="complete.obs") })
})
dl$peak.max.cor

(ggplot(dl$peak.vs.max, aes(x=cbPeaktime, y=predicted.peak))
    + geom_point()
)

```


R version and packages used:
```{r Rversion}
sessionInfo()
```
