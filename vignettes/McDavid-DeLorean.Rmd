---
title: DeLorean analysis of McDavid et al. cell cycle data
author: John Reid
bibliography: DeLorean.bib
output:
  html_document:
    toc: true
    fig_caption: true
    # css: ../inst/Rmd/foghorn.css
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{DeLorean analysis of McDavid et al. cell cycle data}
-->


```{r build, echo=FALSE, eval=FALSE}
library(devtools)
load_all('..')
library(rmarkdown)
render('McDavid-DeLorean.Rmd')

```


```{r config, echo=FALSE, message=FALSE}
library(knitr)
library(knitcitations)
library(rmarkdown)
#
# knitr options
#
opts_chunk$set(
    fig.path = 'figures/McDavid-',
    stop_on_error = TRUE,
    fig.width = 12.5,
    fig.height = 8)
#
# Citations
#
cleanbib()
cite_options(
    # hyperlink = 'to.doc',
    hyperlink = TRUE,
    # style = 'html',
    # citation_format = 'text',
    citation_format = "pandoc",
    cite.style = "numeric",
    check.entries = TRUE)
    # hyperlink = TRUE)
bib <- read.bibtex("DeLorean.bib")
if (file.exists("config.R")) {
    source("config.R")
}
#
# Widths for saving figures
#
text.width <- 4.79  # LaTeX width in inches
golden.ratio <- 1.618  # Pleasing ratio
fig.width <- text.width
fig.height <- text.width / golden.ratio

```

```{r init, echo=FALSE, message=FALSE, warning=FALSE}
# suppressMessages(loadfonts())
library(DeLorean)
#
# Stylesheet
#
options(markdown.HTML.stylesheet = system.file("inst/Rmd/foghorn.css",
                                               package="DeLorean"))
font.family <- "Verdana"
font.theme <- theme_update(text=element_text(family=font.family))
theme_set(font.theme)

```


`r citet(bib[["mcdavid_modeling_2014"]])` assayed actively cycling single
cells in order to examine the confounding effect of the cell cycle on
single cell expression analyses. They measured the expression of 333 genes
in 930 cells across three cell cycle phases and three cell lines.


# Data

McDavid et al.'s data is available in the `DeLorean` R package. Not all 333
genes are represented as several are rarely expressed.
```{r loadLib}
library(DeLorean)
data(McDavidDeLorean)

```

Shift positively expressed genes closer to unexpressed genes to improve fit.
```{r}
dl <- de.lorean(
    pmax(mcdavid.expr - .69, 0),
    mcdavid.gene.meta,
    mcdavid.cell.meta)

```

```{r child=report.file("data")}
```



# PCA analysis

```{r}
genes.high.rank <- (
    dl$gene.meta
    %>% filter(!is.na(cbRank), cbRank < 201)
    %>% arrange(cbRank))
levels(dl$cell.meta$cellline)
cells.PC3 <- mcdavid.cell.meta %>% filter("PC3" == cellline)
pca <- prcomp(t(mcdavid.expr[as.character(genes.high.rank$gene),
                             as.character(cells.PC3$cell)]),
              .scale=TRUE)
# Sqrt of eigenvalues
qplot(pca$sdev)
# Percentage of variance explained
qplot(pca$sdev**2 / sum(pca$sdev**2) * 100)
# Get the PC scores
pc.scores <- as.data.frame(pca$x)
pc.scores$cell <- factor(rownames(pca$x), levels=levels(dl$cell.meta$cell))
pc.scores <- pc.scores %>% left_join(dl$cell.meta)
# Plot PC1 against PC2
ggplot(pc.scores, aes(x=PC1, y=PC2, color=capture)) + geom_point()
# Plot PC1 against PC3
ggplot(pc.scores, aes(x=PC1, y=PC3, color=capture)) + geom_point()

```


# Choose genes and cells

Choose a few cells from the PC3 cell line.
```{r filterCells}
dl <- filter.cells(dl, cells=cells.PC3$cell)
set.seed(getOption("McDavid.seed", 1))
max.cells <- min(getOption("McDavid.max.cells", 17))
dl <- filter.cells(dl, number=max.cells)

```


Choose genes with low $p$-values from the McDavid et al.
differential expression test.
```{r filterGenes}
max.genes <- min(getOption("McDavid.max.genes", 21))
genes.for.stan <- (
    dl$gene.meta
    %>% filter(pvalue > 10)
    %>% sample_n(max.genes))
dl <- filter.genes(dl, genes=genes.for.stan$gene)

```


# Estimate hyperparameters

Examine data for empirical Bayes estimation of hyperparameters.
```{r empiricalBayes}
dl <- adjust.by.cell.sizes(dl)
ggplot(dl$cell.sizes, aes(x=capture, y=size)) + geom_boxplot()
dl <- estimate.hyper(
    dl,
    sigma.tau=.5,
    length.scale=5,
    delta=.5,
    model.name=getOption("McDavid.model", 'simple-model'))

```

```{r child=report.file("hyper-parameters")}
```


Save expression data and meta data.
```{r}
saveRDS(list(expr = dl$expr, cell.meta = dl$cell.map, gene.meta=dl$gene.map),
        file='McDavid-input.rds')

```


# Compile and fit model

Define and compile the model, find the best initialisation, and fit the model.
```{r model}
dl <- format.for.stan(dl, period=3, hold.out=3)
dl <- compile.model(dl)
dl <- find.best.tau(dl)
# dl <- find.smooth.tau(dl)
system.time(dl <- fit.model(dl))

```


# Examine convergence.

```{r examConv}
dl <- examine.convergence(dl)

```

```{r child=report.file("convergence")}
```



# Analyse posterior

Examine posterior.
```{r posterior}
dl <- process.posterior(dl)
# dl <- optimise.best.sample(dl)
dl <- analyse.noise.levels(dl)

```

```{r child=report.file("posterior")}
```


# Profiles

Calculate expression profiles.
```{r makePredictions}
dl <- make.predictions(dl)
```

```{r child=report.file("profiles")}
```


# Cell size vs. pseudotime

```{r}
periodise <- function(tau, period=3) {
    wave = floor(tau/period)
    tau - wave * period
}
# Make predictions at times used in predictedmean
prediction.times <- (
    dl$predictions
    %>% filter(dl$best.sample == iter,
                1 == g,
                0 <= tau,
                tau <= dl$opts$period)
    %>% select(t, tau))
if (dl$opts$estimate.phi) {
    tau.S <- (
        dl$samples$tau
        %>% left_join(dl$samples$S)
        %>% mutate(tau=periodise(tau, dl$opts$period))
        %>% arrange(tau))
    # Copy data to beginning and end to ensure periodic loess estimate
    tau.S.lower <- tau.S %>% tail(9000) %>% mutate(tau=tau-dl$opts$period)
    tau.S.upper <- tau.S %>% head(9000) %>% mutate(tau=tau+dl$opts$period)
    tau.S <- rbind(tau.S.lower, tau.S, tau.S.upper)
    # Fit loess
    lo <- loess(S ~ tau, tau.S, span=.33)
    tau.S$loess <- predict(lo, tau.S)
    prediction.times$S <- predict(lo, prediction.times)
    # Plot data + fit
    gp <- (ggplot(tau.S, aes(x=tau, y=S, color=capture))
        + geom_point(alpha=.4)
        + geom_line(aes(y=loess), color='black')
        + scale_x_continuous(name="pseudotime")
        + scale_y_continuous(name="cell size")
        + scale_color_discrete(name="phase")
        + coord_cartesian(xlim = c(0, 3))
        + guides(colour=guide_legend(override.aes=list(alpha=1)))
    )
    print(gp)
    ggsave('McDavid-cell-size-vs-pseudotime.png', plot=gp,
        width=fig.width, height=fig.height,
        units='in', dpi=72*2)
} else {
    prediction.times$S <- 0
}

```

# Examine peak times

```{r peakTimes}
# Plot cbPeaktime against best sample max predicted mean time
# print(plot.profiles(dl, genes="CDCA8"))
# Distance between two points on unit interval where 0 is connected to 1
peak.distance <- function(peak.1, peak.2) {
    stopifnot(all(peak.1 >= 0.))
    stopifnot(all(peak.1 <= 1.))
    stopifnot(all(peak.2 >= 0.))
    stopifnot(all(peak.2 <= 1.))
    dist <- abs(peak.1 - peak.2)
    ifelse(dist > .5, 1 - dist, dist)
}
# Test peak distances
# peak.distance(c(.1, .2, .1, .9, .5, .5), c(.2, .1, .9, .1, .5, .4))
# Calculate the root mean square of d
calc.rms <- function(d) sqrt(sum(d**2))/length(d)
# Calculate the root mean square error between xhat and x.
calc.rmse <- function(xhat, x) calc.rms(peak.distance(xhat, x))
# cbPeaktimes of 0 (equiv. 100) correspond to the transition
# between M and G1.
# (http://cyclebase2.jensenlab.org/methods.jsp#peaktime-uncertainty)
# Hence cbPeaktime = 0 corresponds to a pseudotime of .5
# A function to map from pseudotimes (tau) to cbPeaktimes
tau.to.cbtime <- function(tau) periodise((tau - .5)/3, 1)
# and vice versa
cbtime.to.tau <- function(cbtime) cbtime*3+.5

```


Calculate distance between peak time and capture time.
Capture times are as defined in
[CycleBase](http://www.cyclebase.org/About "CycleBase").
```{r}
expr.l <- melt(unname(dl$expr), varnames=c("g", "c"), value.name="x")
peaks <- (
    expr.l
    %>% group_by(g)
    %>% summarise(c=c[which.max(x)])
    %>% left_join(dl$gene.map)
    %>% filter(! is.na(cbPeaktime))
    %>% left_join(dl$cell.map)
    %>% mutate(capture.dist=peak.distance(cbPeaktime/100,
                                          tau.to.cbtime(as.integer(capture)))))
capture.RMSE <- calc.rms(peaks$capture.dist)
capture.RMSE

```


```{r predictedPeaks}
dl <- within(dl, {
    # Find the peaks in the predicted profiles
    peak.vs.max <- (
        predictions
        %>% left_join(prediction.times %>% select(-tau))
        %>% group_by(iter, g)
        %>% summarise(predicted.peak=tau.to.cbtime(tau[which.max(predictedmean)]),
                      predicted.peak.adj=tau.to.cbtime(tau[which.max(predictedmean+S)]))
        %>% left_join(gene.map)
        %>% filter(! is.na(cbPeaktime)))
    # Calculate the distance between the peaks and the CycleBase peaktimes
    peak.max.dist <- (
        peak.vs.max
        %>% group_by(iter)
        %>% summarise(rmse=calc.rmse(cbPeaktime/100,
                                     predicted.peak),
                      rmse.adj=calc.rmse(cbPeaktime/100,
                                         predicted.peak.adj)))
})
best.peak.dist <- with(dl, filter(peak.max.dist, best.sample == iter)$rmse)
sample_n(dl$peak.max.dist, 15)
gp <- (
    ggplot(dl$peak.max.dist, aes(x=rmse, y=rmse.adj))
    + geom_point()
    + scale_x_continuous(name="RMSE (not adjusted)")
    + scale_y_continuous(name="RMSE (cell size adjusted)")
    + geom_abline(alpha=.5)
    + geom_hline(y=capture.RMSE, linetype='dashed')
    + geom_vline(x=capture.RMSE, linetype='dashed')
)
print(gp)
ggsave('McDavid-rmse-vs-rmse-adj.pdf', plot=gp,
       width=fig.width, height=fig.height)
ggsave('McDavid-rmse-vs-rmse-adj.png', plot=gp,
       width=fig.width*1.75, height=fig.height*1.5,
       units="in", dpi=200)
# Test for normality
with(dl$peak.max.dist, shapiro.test(rmse.adj))
with(dl$peak.max.dist, shapiro.test(rmse))
# Plot distribution
gp <- (
    ggplot(dl$peak.max.dist, aes(x=rmse.adj))
    + geom_density()
    + geom_rug()
    + geom_vline(x=capture.RMSE, linetype='dashed')
    + geom_vline(x=best.peak.dist, linetype='dotted')
    + scale_x_continuous(name="RMSE"))
print(gp)
ggsave('McDavid-rmse-adj.pdf', plot=gp,
       width=fig.width, height=fig.height)
ggsave('McDavid-rmse-adj.png', plot=gp,
       width=fig.width*1.75, height=fig.height*1.5,
    units="in", dpi=200)

gp <- (
    ggplot(dl$peak.max.dist, aes(sample=rmse.adj))
    + stat_qq())
ggsave('McDavid-rmse-adj-qq.pdf', plot=gp,
       width=fig.width, height=fig.height)
# t-test for differences
# Don't know which test to do yet.
# with(dl$peak.max.dist, t.test(x=rmse,
                              # y=rmse.adj,
                              # paired=TRUE,
                              # alternative="greater"))
# Mean of both RMSEs
mean(dl$peak.max.dist$rmse)
mean(dl$peak.max.dist$rmse.adj)
gp <- (
    ggplot(dl$peak.vs.max %>% filter(dl$best.sample == iter),
           aes(x=cbPeaktime, y=predicted.peak, label=gene))
    + geom_point(alpha=.7, size=2)
    + scale_x_continuous(name="CycleBase peak time")
    + scale_y_continuous(name="estimated peak time")
    + geom_point(aes(y=predicted.peak.adj), alpha=.7, size=2, color="blue")
)
print(gp)
ggsave('McDavid-peak-vs-max.pdf', plot=gp,
       width=fig.width, height=fig.height)
ggsave('McDavid-peak-vs-max.png', plot=gp,
       width=fig.width*1.75, height=fig.height*1.5,
       units="in", dpi=200)

```

```{r testPeaks}
# Haven't decided which test to do yet.
# t-test
#with(dl$peak.max.dist, t.test(x=capture.RMSE,
                              #y=rmse.adj,
                              #alternative="greater"))

# Assuming a normal distribution for the adjusted RMSE, what is
# the likelihood of observing at least as extreme as the
# peak capture RMSE.
with(dl$peak.max.dist, pnorm(capture.RMSE,
                             mean=mean(rmse.adj),
                             sd=sd(rmse.adj),
                             lower.tail=F))
gp <- (
    ggplot(peaks %>% filter(! is.na(cbPeaktime)), aes(x=capture, y=cbPeaktime))
    + geom_boxplot()
    + scale_y_continuous(name="CycleBase peak time")
    + scale_x_discrete(name="cell cycle phase")
    + coord_flip())
print(gp)
ggsave('McDavid-capture-peaks.pdf', plot=gp,
       width=fig.width, height=fig.height)
ggsave('McDavid-capture-peaks.png', plot=gp,
       width=fig.width*3.5, height=fig.height*3,
       units="in", dpi=100)

```


Plot the profiles adjusted for the cell size.
```{r}
if (dl$opts$estimate.phi) {
    gp <- plot(dl, type="profiles", cell.size.adj=F, adjust.model=lo)
    print(gp)
    ggsave('McDavid-profiles-adj.pdf', plot=gp,
        width=fig.width*2, height=fig.height*2)
}
gp <- (
    plot(dl, type="profiles")
    + scale_x_continuous(name='Pseudotime', limits=c(0, 3))
)
add.peak.times <- function(dl, gp) {
    plot.peaktimes <- (
        dl$gene.meta
        %>% filter(gene %in% gp$data[['gene']], ! is.na(cbPeaktime))
        %>% mutate(tau=periodise(cbtime.to.tau(cbPeaktime/100))))
    (
        gp
        + geom_vline(data=plot.peaktimes,
                    aes(xintercept=tau, color=expPeaktime),
                    linetype='dashed',
                    alpha=.7)
    )
}
gp <- add.peak.times(dl, gp)
print(gp)
ggsave('McDavid-profiles.png', plot=gp,
    width=fig.width*3.5, height=fig.height*3,
    units="in", dpi=100)
ggsave('McDavid-profiles.pdf', plot=gp, width=fig.width*2, height=fig.height*2)

```


```{r echo=FALSE}
# Save DeLorean object without fit component
saveRDS({dl2 <- dl; dl2$fit <- NULL; dl2}, "McDavid.rds")
```


```{r date}
date()
```
R version and packages used:
```{r Rversion}
sessionInfo()
```
