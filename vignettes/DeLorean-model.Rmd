---
title: The DeLorean model
author: John Reid
bibliography: DeLorean.bib
output: html_document
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{The DeLorean model}
-->


```{r config, echo=FALSE, message=FALSE}
library(knitr)
library(knitcitations)
library(rmarkdown)
#
# knitr options
#
opts_chunk$set(
    fig.path = 'figures/model-',
    stop_on_error = TRUE,
    fig.width = 12.5,
    fig.height = 8)
#
# Citations
#
cleanbib()
cite_options(
    # hyperlink = 'to.doc',
    hyperlink = TRUE,
    # style = 'html',
    # citation_format = 'text',
    citation_format = "pandoc",
    cite.style = "numeric",
    check.entries = TRUE)
    # hyperlink = TRUE)
bib <- read.bibtex("DeLorean.bib")

```

```{r build, echo=FALSE, eval=FALSE}
library(devtools)
library(rmarkdown)
load_all('..')
render('DeLorean-model.Rmd')

```

```{r loadLibs, echo=FALSE, message=FALSE}
# suppressMessages(loadfonts())
library(DeLorean)
library(gptk)
library(MASS)
library(ggplot2)
library(dplyr)
library(reshape2)
library(grDevices)
library(extrafont)
#
# Stylesheet
#
options(markdown.HTML.stylesheet = system.file("inst/Rmd/foghorn.css",
                                               package="DeLorean"))

```

```{r setUpThemes, echo=FALSE, message=FALSE}
loadfonts()

mrc.colors <- c(
    rgb(138, 121, 103, maxColorValue=255),
    rgb(217, 165, 41 , maxColorValue=255),
    rgb(153, 152, 40 , maxColorValue=255),
    rgb(117, 139, 121, maxColorValue=255),
    rgb(33 , 103, 126, maxColorValue=255),
    rgb(208, 114, 50 , maxColorValue=255),
    rgb(106, 59 , 119, maxColorValue=255),
    rgb(130, 47 , 90 , maxColorValue=255)
)

#
# Check/install fonts
#
# install.packages("extrafont")
# font_import()
# fonts()
# fonttable()

font.family <- "Verdana"
font.theme <- theme_update(text=element_text(family=font.family))
theme_set(font.theme)

```



# Introduction

DeLorean uses a probabilistic model to estimate pseudotimes in cross-sectional
time-series. The basic idea is that a dynamic regulatory system can be
characterised by the profiles of its genes. That is, as the system moves
between states the genes exhibit characteristic behaviours consistent with the
regulatory network that they encode. Typically the gene expression data we
capture about the system state is cross-sectional in nature. This is because
the cell (or population of cells) are destroyed as part of the assay. We would
prefer to have longtitudinal data whereby a cell is tracked through time and
the expression measurements are made on the same biological object at distinct
time points. However with current technologies this is difficult to acheive.

Biological systems are typically noisy and stochastic in nature. In many
systems we have reason to believe each cell may progress at its own rate.  This
is a particular problem for cross-sectional data as the expression measurements
made at a particular time point are no longer directly comparable. The DeLorean
model estimates pseudotimes that are designed to mitigate this problem. The
pseudotime for a cell represents how far through the system the cell has
progressed. The difference between the pseudotime and the observed time
represents how quickly or slowly the cell has progressed relative to the other
cells. The estimation of pseudotimes is an underdetermined problem and many
plausible estimates are possible. The DeLorean model aims to resolve this by
balancing the smoothness of the expression profiles against the noise levels in
the measurements. We expect gene expression profiles to be smooth over time,
that is we have no reason to believe that genes frequently make many sudden
changes in their expression levels. On the one hand, any given data could be
explained by very smooth expression levels with high levels of noise. Here
the noise would capture almost all the variation in the signal. On the other
hand, extremely dynamic expression profiles can explain the data without any
noise at all.

```{r explanatory}
tmin <- 0
tmax <- 3
twidth <- tmax - tmin
tlims <- c(tmin, tmax)
num.inputs <- 100
inputs <- (0:num.inputs) * twidth / num.inputs + tmin
sigma.gp <- 2
sigma.noise <- .3
kern <- kernCreate(1, 'rbf')
K <- (
    sigma.gp ** 2 * kernCompute(kern, inputs, inputs)
    + diag(sigma.noise ** 2, num.inputs + 1, num.inputs + 1))
output <- mvrnorm(n=1, mu=rep(2, num.inputs+1), Sigma=K)
qplot(x=inputs, y=output)

set.seed(2)
times <- c("0h", "20h", "40h", "60h", "80h")
times <- factor(times, levels=times, ordered=TRUE)
N <- 40
.data <- data.frame(obstime=sample(times, N, replace=TRUE), c=1:N)
.data <- .data %>% mutate(tau=rnorm(n=N, mean=as.integer(obstime), sd=.5))
K <- (
    sigma.gp ** 2 * kernCompute(kern, .data$tau, .data$tau)
    + diag(sigma.noise ** 2, N, N))
mu <- 3
.data$expr <- mvrnorm(n=1, mu=rep(0, N), Sigma=K)
to.hours <- function(.t) (.t - 1) * 20
range(to.hours(.data$tau))
xmin <- -15
xmax <-  95
scale.x <- scale_x_continuous(breaks=to.hours(as.integer(times)), limits=c(xmin, xmax))
scale.obs.time <- scale_colour_manual(name="Observed\ntime", values=mrc.colors)
from.hours <- function(.h) .h / 20 + 1
.data.m <- melt(.data %>% mutate(Observed=to.hours(as.integer(obstime)), Pseudotime=to.hours(tau)),
                id.vars="c",
                measure.vars=c("Observed", "Pseudotime"),
                value.name="time") %>% left_join(.data)
names(.data.m)
sample_n(.data.m, 6)
font.family <- "Verdana"
font.theme <- theme(text=element_text(family=font.family))

(ggplot(.data.m, aes(x=time, y=mu+expr, color=obstime))
    + geom_point(alpha=.6, size=5)
    + xlab("Time")
    + ylab("Expression")
    + scale.obs.time
    + scale.x
    + font.theme
    + facet_grid(variable ~ .)
    + guides(color=FALSE)
)

(ggplot(.data, aes(x=to.hours(as.integer(obstime)), y=mu+expr, color=obstime))
    + geom_point(alpha=.6, size=5)
    + xlab("Cell capture time")
    + ylab("Expression")
    + scale.obs.time
    + scale.x
    + font.theme
    + guides(color=FALSE)
)

(ggplot(.data, aes(x=to.hours(tau), y=mu+expr, color=obstime))
    + geom_point(alpha=.6, size=5)
    + xlab("Latent pseudotime")
    + ylab("Expression")
    + scale.obs.time
    + scale.x
    + font.theme
    + guides(color=FALSE)
)


#
# Make predictions
#
rbfCreate <- function(sigma.gp, length.scale) {
    function(tau1, tau2) {
        d <- outer(tau1, tau2, "-")
        sigma.gp**2 * exp(-(d/length.scale)**2/2)
    }
}
make.predictions <- function(sigma.gp, sigma.noise, length.scale=1) {
    kern <- rbfCreate(sigma.gp, length.scale)
    K <- kern(.data$tau, .data$tau) + diag(sigma.noise ** 2, N, N)
    L <- chol(K)
    max(abs(t(L) %*% L - K))
    alpha <- solve(L, solve(t(L), .data$expr))
    class(alpha)
    max(abs(K %*% alpha - .data$expr))
    # max(L * t(L) - K)
    predictions <- data.frame(input=((10*xmin):(10*xmax))/10)
    xstar <- from.hours(predictions$input)
    Kstar <- kern(.data$tau, xstar)
    predictions$fstar <- mu + as.vector(t(Kstar) %*% alpha)
    v <- solve(t(L), Kstar)
    dim(v)
    Kstarstar <- as.vector(diag(kern(xstar, xstar)) + sigma.noise ** 2)
    dim(Kstarstar)
    predictions$V <- Kstarstar - diag(t(v) %*% v)
    stopifnot(all(predictions$var >= 0))
    predictions
}
# predictions <- make.predictions(sigma.gp=.3, sigma.noise=2)
# predictions <- make.predictions(sigma.gp=2.2, sigma.noise=.1, length.scale=.01)
scale.y <- scale_y_continuous(limits=c(-2, 10))
plot.predictions <- function(predictions) {
    (ggplot(.data, aes(x=to.hours(tau), y=mu+expr))
        + geom_ribbon(data=predictions,
                    aes(x=input,
                        y=fstar,
                        ymin=fstar-2*sqrt(V),
                        ymax=fstar+2*sqrt(V)),
                    alpha=.1)
        + geom_line(data=predictions, aes(x=input, y=fstar))
        + geom_point(aes(color=obstime), alpha=.6, size=5)
        + xlab("Latent pseudotime")
        + ylab("Expression")
        + scale.obs.time
        + scale.x
        + scale.y
        + font.theme
        + guides(color=FALSE)
    )
}
print(plot.predictions(make.predictions(sigma.gp=2 , sigma.noise=.3, length.scale=.1)))
print(plot.predictions(make.predictions(sigma.gp=.3, sigma.noise=2 , length.scale=1)))
print(plot.predictions(make.predictions(sigma.gp=2 , sigma.noise=.3, length.scale=1)))

```


# Data

The DeLorean model is fit to a matrix of expression data for $G$ genes in $C$
cells. Each cell $c$ has been captured at a time point $t_c$. The expression
measurements are modelled using Gaussian processes
(`r citet(bib[["rasmussen_gaussian_2006"]])`) and because of this it is
typically more suitable to use the logarithm of the absolute expression values.


R version and packages used:
```{r Rversion}
sessionInfo()
```
