---
title: DeLorean analysis of Windram et al. Arabidopsis time series
author: John Reid
bibliography: DeLorean.bib
output:
  html_document:
    toc: true
    fig_caption: true
    # css: ../inst/Rmd/foghorn.css
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{DeLorean analysis of Arabidopsis time series}
-->

```{r build, echo=FALSE, eval=FALSE}
library(devtools)
load_all('..')
library(rmarkdown)
# fit.model <- FALSE
fit.model <- TRUE
render('Windram-DeLorean.Rmd')

```


```{r config, echo=FALSE, message=FALSE}
library(knitr)
library(knitcitations)
library(rmarkdown)
#
# knitr options
#
opts_chunk$set(
    fig.path = 'figures/Windram-',
    stop_on_error = TRUE,
    fig.width = 12.5,
    fig.height = 8)
#
# Citations
#
cleanbib()
cite_options(
    # hyperlink = 'to.doc',
    hyperlink = TRUE,
    # style = 'html',
    # citation_format = 'text',
    citation_format = "pandoc",
    cite.style = "numeric",
    check.entries = TRUE)
    # hyperlink = TRUE)
bib <- read.bibtex("DeLorean.bib")
if (file.exists("config.R")) {
    source("config.R")
}
#
# Widths for saving figures
#
text.width <- 4.79  # LaTeX width in inches
golden.ratio <- 1.618  # Pleasing ratio
fig.width <- text.width
fig.height <- text.width / golden.ratio
html5 <- list(width=1300, height=700)  # in pixels
html5$ratio <- with(html5, width / height)
slide.fig.width <- 7

```

```{r loadLibs, echo=FALSE, message=FALSE}
# suppressMessages(loadfonts())
library(DeLorean)
#
# Stylesheet
#
options(markdown.HTML.stylesheet = system.file("inst/Rmd/foghorn.css",
                                               package="DeLorean"))
font.family <- "Verdana"
font.theme <- theme_update(text=element_text(family=font.family))
theme_set(font.theme)

```

`r date()`

`r citet(bib[["windram_arabidopsis_2012"]])` assayed leaves at 24 time points
in 2 conditions.


# Data

Windram et al.'s data is available in the `DeLorean` R package.
```{r loadLib}
library(DeLorean)
data(WindramDeLorean)

```


## Obfuscate time points

Reduce resolution of observed capture time points.
```{r eval=fit.model}
group.size <- 12
windram.cell.meta$obstime.orig <- windram.cell.meta$obstime
windram.cell.meta$capture.orig <- windram.cell.meta$capture
windram.cell.meta$obstime <- (
    floor((windram.cell.meta$obstime-1) / group.size) * group.size
    + group.size / 2)
windram.cell.meta$capture <- (
    factor(as.character(windram.cell.meta$obstime),
           ordered=TRUE,
           levels=unique(as.character(windram.cell.meta$obstime))))

```

Just consider the *Botrytis* cells and select some at random if we have
too many.
```{r eval=fit.model}
dl <- de.lorean(
    windram.expr,
    windram.gene.meta,
    windram.cell.meta)
botrytis.cells <- dl$cell.meta %>% filter(condition == "Botrytis")
dl <- filter.cells(dl, cells=botrytis.cells$cell)

```


```{r checkNewHyper, eval=fit.model}
expr.l <- melt.expr(dl) %>% left_join(dl$cell.meta
                                      %>% dplyr::select(cell, capture))
sigma.tau <- 3
length.scale <- 24
num.tau.samples <- 100
# Covariance for observed times. Will use to estimate psi.
K.obs <- cov.matern.32(cov.calc.dists(unique(cell.meta$obstime)),
                       length.scale)
# Expected variance of samples from zero-mean Gaussian with covariance K.obs
V.obs <- expected.sample.var(K.obs)
sample.V.tau <- function(sigma.tau, length.scale) {
    with(dl, {
        cell.meta <- (
            cell.meta
            %>% filter(cell %in% colnames(expr))
            %>% mutate(c=1:n(),
                       tau=rnorm(n(), mean=obstime, sd=sigma.tau)))
        stopifnot(all(colnames(expr) == cell.meta$cell))
        K <- cov.matern.32(cov.calc.dists(cell.meta$tau), length.scale)
        (
            cell.meta
            %>% group_by(capture)
            %>% summarise(V.tau.c=expected.sample.var(K[c,c]))
            %>% mutate(V.tau=expected.sample.var(K))
        )
    })
}
V.tau <- do.call(rbind,
                 lapply(1:num.tau.samples,
                        function(i) sample.V.tau(sigma.tau, length.scale)))
V.tau.mean <- mean(V.tau$V.tau)
expr.gene.capture <- (
    expr.l
    %>% group_by(gene, capture)
    %>% filter(n() > 1)
    %>% summarise(Mgc=mean(x), Vgc=mean((x-Mgc)^2))
    %>% ungroup()
)
qplot(log(expr.gene.capture$Vgc))
expr.gene <- (
    expr.l
    %>% group_by(gene)
    %>% summarise(Vg=mean((x-mean(x))^2))
)
var.estimates <- (
    expr.gene.capture
    %>% group_by(gene)
    %>% summarise(psi=var(Mgc)/V.obs, omega=mean(Vgc))
)
qplot(var.estimates$omega)
qplot(var.estimates$psi) + scale_x_log10()

test.fit <- function(vars) {
    fit.gamma <- fitdistr(vars, 'gamma')
    fit.lognormal <- fitdistr(vars, 'lognormal')
    gp <- (
        ggplot(data.frame(V=vars), aes(x=V))
        + geom_density()
        + stat_function(fun=Curry(dgamma,
                                shape=fit.gamma$estimate['shape'],
                                rate=fit.gamma$estimate['rate']),
                        linetype='dashed')
        + stat_function(fun=Curry(dlnorm,
                                meanlog=fit.lognormal$estimate['meanlog'],
                                sdlog=fit.lognormal$estimate['sdlog']),
                        linetype='dotted')
    )
    list(gamma=fit.gamma, lognormal=fit.lognormal, gp=gp)
}
fits.omega <- test.fit(var.estimates$omega)
print(fits.omega$gp)
fits.psi <- test.fit(var.estimates$psi)
print(fits.psi$gp)

ggplot(expr.gene, aes(x=log(Vg), y=log(Vgc))) + geom_point()
sample_n(expr.gene, 15)
stopifnot(all(! is.na(expr.gene)))
with(expr.gene, mean(Vg < Vgc))
expr.gene %>% filter(Vg < Vgc)
ggplot(V.tau, aes(x=log(V.tau), y=log(V.tau.c))) + geom_point()
ggplot(V.tau, aes(x=log(V.tau))) + geom_histogram()
ggplot(V.tau, aes(x=log(V.tau.c))) + geom_histogram()
V.tau.capture <- (
    V.tau
    %>% group_by(capture)
    %>% summarise(M=mean(log(V.tau.c)),
                  V=var(log(V.tau.c)))
)
V.tau.capture
ggplot(V.tau, aes(x=V.tau.c, color=capture)) + geom_density() + scale_x_log10()

stopifnot(all(! is.na(V.tau)))
names(V.tau)
# Try quadratic programming to find best alpha and omega
library(quadprog)
gene.test <- 'CATMA1a15390'
solve.alpha.omega <- function(gene.test) {
    expr.test <- (
        expr.gene
        %>% filter(gene.test == gene)
        %>% left_join(V.tau, by="capture")
    )
    Q <- with(expr.test, matrix(c(sum(V.tau.c**2) + sum(V.tau**2) / 4,
                                  - sum(V.tau.c*Vgc) - sum(V.tau*Vg) / 4,
                                  - sum(V.tau.c*Vgc) - sum(V.tau*Vg) / 4,
                                  sum(Vgc**2) + sum(Vg**2) / 4),
                                nrow=2))
    d <- with(expr.test, -c(sum(V.tau.c) + sum(V.tau) / 4,
                            - sum(Vgc) - sum(Vg) / 4))
    A <- diag(1, 2)
    b0 <- c(0, 0)
    QP <- solve.QP(Q, d, Amat=diag(1,2), bvec=rep(0,2))
    alpha <- QP$solution[1]
    omega <- 1/QP$solution[2]
    c(alpha, omega)
}
test.genes <- unique(expr.gene$gene)
emp.alpha.omega.m <- sapply(test.genes, solve.alpha.omega)
emp.alpha.omega <- (
    as.data.frame(t(emp.alpha.omega.m))
    %>% mutate(gene=test.genes)
)
colnames(emp.alpha.omega) <- c('alpha', 'omega', 'gene')
emp.alpha.omega
names(emp.alpha.omega)
ggplot(emp.alpha.omega, aes(x=alpha, y=omega, label=gene)) + geom_text()
# ggplot(emp.alpha.omega, aes(x=alpha)) + geom_histogram() + scale_x_log10()

# Test expectation of moment under Gaussian and relation to Gamma
alpha <- 2
beta <- .7
a <- 1.2
a2 <- a**2
b <- 1.8
N <- 10000
gamma.samples <- (
    data.frame(tau=rgamma(N, shape=alpha, rate=beta))
    %>% mutate(value=exp(-.5*(a2*tau**2+b*tau))))
mean(gamma.samples$value)
gaussian.mu <- (2*beta+b)/(2*a2)
gaussian.samples <- (
    data.frame(tau=rnorm(N, mean=gaussian.mu, sd=1/a))
    %>% mutate(tmp=tau**(alpha-1), value=exp(-gaussian.mu**2)*tau**(alpha-1)))
mean(gaussian.samples$value)

alpha.dist <- (
    expr.gene
    %>% left_join(V.tau)
    %>% mutate(Vg.diff=Vg-Vgc,
               V.diff=V.tau*Vgc-V.tau.c*Vg,
               alpha=(Vg-Vgc)/(V.tau*Vgc-V.tau.c*Vg),
               log.alpha=log(alpha))
)
alpha.gene <- (
    alpha.dist
    %>% group_by(gene)
    %>% summarise(alpha.mean=mean(alpha), alpha.sd=sd(alpha))
)
qplot(alpha.dist$log.alpha)
nrow(alpha.dist)
sum(alpha.dist$alpha < 0)
sum(alpha.dist$Vg.diff < 0)
sum(alpha.dist$V.diff < 0)
mean(alpha.dist$log.alpha, na.rm=TRUE)
exp(mean(alpha.dist$log.alpha, na.rm=TRUE))

log.estimate <- (
    expr.gene
    %>% left_join(V.tau)
    %>% mutate(log.alpha=log(Vg)-log(Vgc)-log(V.tau-V.tau.c))
)
sum(is.na(log.estimate$log.alpha))
qplot(log.estimate$log.alpha)
log.estimate.gene <- (
    log.estimate
    %>% group_by(gene)
    %>% summarise(log.alpha.mean=mean(log.alpha), log.alpha.sd=sd(log.alpha))
)
ggplot(log.estimate.gene, aes(x=log.alpha.mean, y=log.alpha.sd)) + geom_point()
qplot(log.estimate.gene$log.alpha.mean)

ggplot(expr.gene, aes(x=Mgc, y=sqrt(Vgc))) + geom_point()
ggplot(expr.gene, aes(x=sqrt(Vg), y=sqrt(Vgc))) + geom_point()
ggplot(expr.gene, aes(x=Vg, y=Vgc)) + geom_point()

# create 3x3 covariance matrix
library(MASS)
set.seed(1000)
m1 <- c( 100.1 , 100.1, 100.1 )
S1 <- matrix( c( .1 , .05 , .02 , .05 , .1 , .03 , .02 , .03 , .1 ), nrow = 3 )
# draw 10,000 times from covariance matrix
draws <- MASS::mvrnorm(10000,mu=m1,Sigma=S1)
# measure the "cross-sectional" dispersion at each row
rowDispersion <- apply( draws , 1 , function(x) mean((x-mean(x))^2))
# measure the mean cross-sectional dispersion
mean( rowDispersion )
# measure the variance of cross-sectional dispersion
var( rowDispersion )
expected.sample.var(S1)

```


```{r sampleCells, eval=fit.model}
set.seed(1)
max.cells <- min(getOption("Windram.max.cells", 24))
dl <- filter.cells(dl, number=max.cells)

```

```{r child=report.file("data")}
```


## Adjust by cell sizes

```{r testCellSize}
dl <- adjust.by.cell.sizes(dl)
ggplot(dl$cell.sizes, aes(x=capture, y=size)) + geom_boxplot()

```


# Estimate hyperparameters

Examine data for empirical Bayes estimation of hyperparameters.
```{r empiricalBayes, eval=fit.model}
dl <- estimate.hyper(
    dl,
    sigma.tau=group.size / 2,
    delta=.5,
    model.name='simplest-model')

```

```{r child=report.file("hyper-parameters")}
```


# Choose genes

Choose a few genes.
```{r filterGenes, eval=fit.model}
max.genes <- min(getOption("Windram.max.genes", 100))
sampled.genes <- sample_n(dl$gene.meta, max.genes)$gene
gene.filter <- function(genes) genes %in% sampled.genes
dl <- filter.genes(dl, gene.filter)

```


Save expression data and meta data.
```{r eval=fit.model}
saveRDS(list(expr = dl$expr, cell.meta = dl$cell.map, gene.meta=dl$gene.map),
        file='Windram-input.rds')

```


Format the data for Stan and fit the model.
```{r fitModel, eval=fit.model}
dl <- format.for.stan(dl)
dl <- compile.model(dl)
dl <- find.best.tau(dl)
system.time(dl <- fit.model(dl))

```


# Examine convergence.

```{r examConv}
dl <- examine.convergence(dl)

```

```{r child=report.file("convergence")}
```



# Analyse posterior

Examine posterior.
```{r posterior}
dl <- process.posterior(dl)
dl <- analyse.noise.levels(dl)

```
```{r child=report.file("posterior")}
```


# Profiles

Calculate expression profiles.
```{r makePredictions}
dl <- make.predictions(dl)
```
```{r child=report.file("profiles")}
```


# Examine pseudotime

Did `DeLorean` learn the obfuscated pseudotime?
```{r pseudotime}
gp.pseudo <- with(dl, {
    (ggplot(samples.l$tau %>% filter(iter == best.sample),
                    aes(x=tau, y=obstime.orig, color=capture),
                    environment=environment())
        + geom_point()
        # + scale_x_continuous(name="pseudotime")
        # + scale_y_continuous(name="capture time")
        # + scale_color_discrete(name="low-resolution\ngroup")
        + scale_y_continuous(name="true capture time")
        + scale_x_continuous(name="pseudotime")
        + scale_color_discrete(name="model\ncapture\ntime")
    )
})
print(gp.pseudo)
# png('pseudotime-vs-obfuscated.png')
ggsave('Windram-pseudotime-vs-obfuscated.png', gp.pseudo,
       width=slide.fig.width, height=slide.fig.width / html5$ratio,
       dpi=300, units="in")
# Save profiles as well
ggsave('Windram-Rhat.png', plot(dl, type="convergence"),
       width=slide.fig.width, height=slide.fig.width / html5$ratio,
       dpi=300, units="in")
# Save profiles as well
ggsave('Windram-profiles.png', plot(dl, type="profiles"),
       width=slide.fig.width * 2, height=slide.fig.width * 2/ html5$ratio,
       dpi=150, units="in")
# Save tau posterior
gp.tau.posterior <- (
    ggplot(dl$samples.l$tau, aes(x=capture.orig, y=tau, color=capture))
    + geom_boxplot()
    # + theme(axis.text.x = element_text(angle = 90, hjust = 1))
    # + theme_gray(base_size=24)
    + scale_x_discrete(name="true capture time")
    + scale_y_continuous(name="pseudotime")
    + scale_color_discrete(name="model\ncapture\ntime")
    + coord_flip())
ggsave('Windram-tau-posterior.png', gp.tau.posterior,
       width=slide.fig.width, height=slide.fig.width / html5$ratio,
       dpi=300, units="in")

```


Look at the expected correlation between the obfuscated capture time with the
pseudotime in the full posterior.
```{r}
posterior.cor <- (
    dl$samples.l$tau
    %>% group_by(iter)
    %>% summarise(pseudotime.capture.cor=cor(tau, obstime.orig,
                                             method="spearman"))
)
mean(posterior.cor$pseudotime.capture.cor)
gp.post.cor <- (ggplot(posterior.cor, aes(x=pseudotime.capture.cor))
    + geom_histogram()
    + geom_vline(x=.94, linetype='dashed', color='red')
    + scale_x_continuous(name="correlation"))
print(gp.post.cor)
ggsave('Windram-posterior-cor.pdf', plot=gp.post.cor,
       width=fig.width, height=fig.height)
ggsave('Windram-posterior-cor.png', gp.post.cor,
       width=slide.fig.width / 2, height=slide.fig.width / 2 / html5$ratio,
       dpi=300, units="in")

```


The correlation between the obfuscated capture time with the pseudotime of
the best sample.
```{r}
with(dl$samples.l$tau %>% filter(iter == dl$best.sample),
     cor(tau, obstime.orig, method="spearman"))

```

# Evaluate held out genes

Fit some held out genes.
```{r heldOutGenes}
held.out.genes <- with(dl, gene.var
                           %>% left_join(gene.meta)
                           %>% filter(! gene %in% gene.map$gene)
                           %>% arrange(-Psi/Omega)
                           %>% head(getOption('Windram.held.out', 100)))
held.out.expr <- windram.expr[as.character(held.out.genes$gene),
                              as.character(dl$cell.map$cell)]

```


## Roughness permutation test

Permutation test for roughness.
```{r}
dl <- roughness.test(dl, held.out.expr)
print(dl$roughness.test)
# Plot the roughnesses
gp <- plot(dl, type="roughnesses")
print(gp)
ggsave('Windram-roughnesses.png', gp)

```


## Fit GPs

```{r fitHeldOut}
held.out.fits <- fit.held.out(dl, held.out.expr)
#held.out.fits$loess[[1]]$tau
#held.out.fits$loess[[1]]$capture

#loess.fit.tau <- held.out.fits$loess[[1]]$tau
#loess.fit.tau

#.pdata <- data.frame(tau=dl$stan.data$testinput)
#pred <- predict(gam.fit.tau, .pdata, type = "response", se.fit = TRUE)
#names(pred)
#.pdata$x <- pred$fit
#ggplot(.pdata, aes(x=tau, y=x)) + geom_path()



held.out.genes$marg.LL.tau <- held.out.fits[1,]
held.out.genes$marg.LL.capture <- held.out.fits[2,]
held.out.gp <- (
    ggplot(held.out.genes,
           aes(x=marg.LL.tau,
               y=marg.LL.capture,
               color=Psi))
    + geom_point()
    + scale_colour_gradient(high="red")
    + geom_abline(intercept=0, slope=1))
print(held.out.gp)
ggsave('Windram-held-out.png', held.out.gp)
with(held.out.genes, t.test(marg.LL.tau, marg.LL.capture,
                            paired=TRUE, alternative="greater"))

```


```{r echo=FALSE}
# Save DeLorean object without fit component
saveRDS({dl2 <- dl; dl2$fit <- NULL; dl2}, "Windram.rds")
# dl <- readRDS("Windram.rds")

```

```{r savePlots, echo=FALSE, eval=FALSE}
plots <- with(dl, list(
    tau.posterior = (
        ggplot(samples.l$tau %>% arrange(capture),
            aes(x=cell, y=tau, color=capture))
        + geom_boxplot()
        + coord_flip()
    ),
    profiles = plot(dl, type="profiles")
))
saveRDS(plots, "Windram-plots.rds")

```

R version and packages used:
```{r Rversion}
date()
sessionInfo()
```
