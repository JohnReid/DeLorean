---
title       : Pseudotime estimation
subtitle    : Modelling noise in the temporal dimension
author      : John Reid
job         :
framework   : io2012        # {io2012, html5slides, shower, dzslides, ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow      #
widgets     : [mathjax]     # {mathjax, quiz, bootstrap}
mode        : selfcontained # {standalone, draft}
knit        : slidify::knit2slides
---

<style>
em {
  font-style: italic
}
</style>

```{r compile, echo=FALSE, eval=FALSE}
devtools::load_all("/home/john/Dev/DeLorean")
library(slidify)
slidify('index.Rmd')
```

```{r knitConfig, echo=FALSE}
knitr::opts_chunk$set(
    fig.path = 'figures/slides-',
    # fig.width = 12,
    # fig.height = 8,
    dev = 'svg',
    stop_on_error = TRUE)
```

```{r fig-templates, echo=FALSE}
knitr::opts_template$set(half.slide.fig = list(
    echo=FALSE,
    message=FALSE,
    fig.width=4,
    fig.height=4.25,
    out.width="500px",
    dpi=72*2))
knitr::opts_template$set(half.height.fig = list(
    echo=FALSE,
    message=FALSE,
    fig.width=8,
    fig.height=2,
    out.width="1000px",
    dpi=72*2))
knitr::opts_template$set(full.slide.fig = list(
    echo=FALSE,
    message=FALSE,
    fig.width=8,
    fig.height=4.25,
    out.width="1000px",
    dpi=72*2))
knitr::opts_template$set(prior.fig = list(
    echo=FALSE,
    message=FALSE,
    fig.width=8,
    fig.height=4,
    out.width="900px",
    dpi=72*2))
set.seed(2)
y.axis = scale_y_continuous("f(x)")
```
```

```{r loadLibs, echo=FALSE, message=FALSE}
library(gptk)
library(matrixcalc)
library(MASS)
library(ggplot2)
library(dplyr)
library(reshape2)
library(grDevices)
library(functional)
```

```{r colourConfig, echo=FALSE}
mrc.colors <- c(
    rgb(138, 121, 103, maxColorValue=255),
    rgb(217, 165, 41 , maxColorValue=255),
    rgb(153, 152, 40 , maxColorValue=255),
    rgb(117, 139, 121, maxColorValue=255),
    rgb(33 , 103, 126, maxColorValue=255),
    rgb(208, 114, 50 , maxColorValue=255),
    rgb(106, 59 , 119, maxColorValue=255),
    rgb(130, 47 , 90 , maxColorValue=255)
)
```

```{r exp-init, echo=FALSE, message=FALSE}
tmin <- 0
tmax <- 3
twidth <- tmax - tmin
tlims <- c(tmin, tmax)
num.inputs <- 100
inputs <- (0:num.inputs) * twidth / num.inputs + tmin
sigma.gp <- 2
sigma.noise <- .3
kern <- gptk::kernCreate(1, 'rbf')
K <- (
    sigma.gp ** 2 * gptk::kernCompute(kern, inputs, inputs)
    + diag(sigma.noise ** 2, num.inputs + 1, num.inputs + 1))
output <- mvrnorm(n=1, mu=rep(2, num.inputs+1), Sigma=K)
# qplot(x=inputs, y=output)
set.seed(2)
times <- c("0h", "20h", "40h", "60h", "80h")
times <- factor(times, levels=times, ordered=TRUE)
N <- 40
.data <- data.frame(obstime=sample(times, N, replace=TRUE), c=1:N)
.data <- .data %>% mutate(tau=rnorm(n=N, mean=as.integer(obstime), sd=.5))
K <- (
    sigma.gp ** 2 * gptk::kernCompute(kern, .data$tau, .data$tau)
    + diag(sigma.noise ** 2, N, N))
mu <- 3
.data$expr <- mvrnorm(n=1, mu=rep(0, N), Sigma=K)
to.hours <- function(.t) (.t - 1) * 20
# range(to.hours(.data$tau))
xmin <- -15
xmax <-  95
scale.x <- scale_x_continuous(breaks=to.hours(as.integer(times)),
                              limits=c(xmin, xmax))
scale.obs.time <- scale_colour_manual(name="Observed\ntime", values=mrc.colors)
from.hours <- function(.h) .h / 20 + 1
.data.m <- melt(.data %>% mutate(Observed=to.hours(as.integer(obstime)),
                                 Pseudotime=to.hours(tau)),
                id.vars="c",
                measure.vars=c("Observed", "Pseudotime"),
                value.name="time") %>% left_join(.data)
# names(.data.m)
# sample_n(.data.m, 6)
#
# Make predictions
#
rbfCreate <- function(sigma.gp=1, length.scale=1) {
    function(tau1, tau2) {
        d <- outer(tau1, tau2, "-")
        sigma.gp**2 * exp(-(d/length.scale)**2/2)
    }
}
periodicRbfCreate <- function(sigma.gp=1, period=1, length.scale=1) {
    function(tau1, tau2) {
        d <- abs(outer(tau1, tau2, "-"))
        sigma.gp**2 * exp(-(period/2*sin(d*pi/period)/length.scale)**2/2)
    }
}
matern32Create <- function(sigma.gp=1, length.scale=1) {
    function(tau1, tau2) {
        d <- abs(outer(tau1, tau2, "-"))
        r <- sqrt(3) / length.scale * d
        sigma.gp**2 * (1 + r) * exp(-r)
    }
}
matern52Create <- function(sigma.gp=1, length.scale=1) {
    function(tau1, tau2) {
        d <- abs(outer(tau1, tau2, "-"))
        r <- sqrt(5) / length.scale * d
        sigma.gp**2 * (1 + r + (r*r)/3) * exp(-r)
    }
}
rationalQuadCreate <- function(sigma.gp=1, alpha=1, length.scale=1) {
    function(tau1, tau2) {
        d <- abs(outer(tau1, tau2, "-"))
        r <- d / length.scale
        sigma.gp**2 * (1 + r**2/(2*alpha)) ** (-alpha)
    }
}
linearCreate <- function(sigma.gp=1, alpha0=0) {
    function(tau1, tau2) {
        sigma.gp**2 * (alpha0**2 + tau1 %*% t(tau2))
    }
}
make.predictions <- function(sigma.gp, sigma.noise, length.scale=1) {
    kern <- rbfCreate(sigma.gp, length.scale)
    K <- kern(.data$tau, .data$tau) + diag(sigma.noise ** 2, N, N)
    L <- chol(K)
    max(abs(t(L) %*% L - K))
    alpha <- solve(L, solve(t(L), .data$expr))
    class(alpha)
    max(abs(K %*% alpha - .data$expr))
    # max(L * t(L) - K)
    predictions <- data.frame(input=((10*xmin):(10*xmax))/10)
    xstar <- from.hours(predictions$input)
    Kstar <- kern(.data$tau, xstar)
    predictions$fstar <- mu + as.vector(t(Kstar) %*% alpha)
    v <- solve(t(L), Kstar)
    dim(v)
    Kstarstar <- as.vector(diag(kern(xstar, xstar)) + sigma.noise ** 2)
    dim(Kstarstar)
    predictions$V <- Kstarstar - diag(t(v) %*% v)
    stopifnot(all(predictions$var >= 0))
    predictions
}
# predictions <- make.predictions(sigma.gp=.3, sigma.noise=2)
# predictions <- make.predictions(sigma.gp=2.2, sigma.noise=.1, length.scale=.01)
scale.y <- scale_y_continuous(limits=c(-2, 10))
plot.predictions <- function(predictions) {
    (ggplot(.data, aes(x=to.hours(tau), y=mu+expr))
        + geom_ribbon(data=predictions,
                    aes(x=input,
                        y=fstar,
                        ymin=fstar-2*sqrt(V),
                        ymax=fstar+2*sqrt(V)),
                    alpha=.1)
        + geom_line(data=predictions, aes(x=input, y=fstar))
        + geom_point(aes(color=obstime), alpha=.6, size=5)
        + xlab("Pseudotime")
        + ylab("Expression")
        + scale.obs.time
        + scale.x
        + scale.y
        + guides(color=FALSE)
    )
}
sample.from.prior <- function(cov.fn, n=3, xstar=(0:600)/200, eps=1e-6) {
    N <- length(xstar)
    K <- cov.fn(xstar, xstar) + diag(eps, N, N)
    samples.prior <- mvrnorm(n=n, rep(0, N), K)
    dimnames(samples.prior) <- list(sample=1:n, x=xstar)
    melt(samples.prior, value.name="y")
}
posterior.covariance <- function(cov.fn, xstar=(0:600)/200, eps=0, x, y)
{
    .A <- cov.fn(xstar, xstar)
    .B <- cov.fn(x    , x    ) + diag(eps**2, length(x), length(x))
    .C <- cov.fn(xstar, x    )
    mu <- .C %*% qr.solve(.B, y)
    K <- .A - .C %*% qr.solve(.B, t(.C))
    list(x=xstar, A=.A, B=.B, C=.C, mu=mu, K=K)
}
sample.from.posterior <- function(cov.fn, n=3, xstar=(0:600)/200, eps=0, x, y)
{
    N <- length(xstar)
    cov.post <- posterior.covariance(cov.fn, xstar, eps, x, y)
    with(cov.post, {
        samples.prior <- mvrnorm(n=n, mu, K)
        dimnames(samples.prior) <- list(sample=1:n, x=xstar)
        melt(samples.prior, value.name="y")
    })
}
posterior.as.df <- function(cov.post, eps=0) {
    with(cov.post, data.frame(x=x, mu=mu, V=diag(K) + eps**2))
}
plot.posterior <- function(post.df, data, size=5, y.offset=0) {
    (
        ggplot(post.df, aes(x=x, y=mu+y.offset), environment=environment())
        + geom_line()
        + geom_point(data=data, aes(y=y+y.offset), size=size)
        + geom_ribbon(aes(ymax=mu+2*sqrt(V)+y.offset,
                          ymin=mu-2*sqrt(V)+y.offset),
                      alpha=.3)
        + y.axis
    )
}
lin.space <- function(start, stop, num.points) {
    (0:(num.points-1)) / (num.points-1) * (stop-start) + start
}
```

## Overview
- Single cell transcriptomics and pseudotime estimaion
- Existing methods
- Gaussian process latent variable model
- Results
  * Arabidoposis response to infection
  * Cell cycle
  * Paracrine signalling

--- .class #id
## Single cell transcriptomics

--- .class #id
## Cross-sectional time series
- Not longitudinal: samples are destroyed when assayed
- Typically handful of capture times
- Biological variation in the cells progression

--- .class #id
## Pseudotimes
```{r exp-capture, opts.label="half.height.fig", echo=FALSE}
gp.capture <- (
    ggplot(.data, aes(x=to.hours(as.integer(obstime)), y=mu+expr, color=obstime))
    + geom_point(alpha=.6, size=5)
    + xlab("Cell capture time")
    + ylab("Expression")
    + scale.obs.time
    + scale.x
    + guides(color=FALSE)
)
print(gp.capture)
```

```{r exp-pseudotime, opts.label="half.height.fig"}
gp.pseudotime <- (
    ggplot(.data, aes(x=to.hours(tau), y=mu+expr, color=obstime))
    + geom_point(alpha=.6, size=5)
    + xlab("Pseudotime")
    + ylab("Expression")
    + scale.obs.time
    + scale.x
    + guides(color=FALSE)
)
print(gp.pseudotime)
```

--- .class #id
## Monocle
<img src="../Figures/monocle.png" alt="Monocle algorithm" height="300" width="800">

Trapnell *et al.* (Nature Biotech. 2014)

--- .class #id
## Waterfall
<img src="../Figures/waterfall.png" alt="Waterfall algorithm" height="500" width="350">

Shin *et al.* (Cell Stem Cell 2015)

--- .class #id
## Embeddr
<img src="../Figures/embeddr.png" alt="Embeddr algorithm" height="500" width="700">

Campbell *et al.* (bioRxiv 2015)

--- .class #id
## GPseudotime
<img src="../Figures/gpseudotime.png" alt="GPseudotime algorithm" height="500" width="800">

Campbell and Yau (bioRxiv 2015)

--- .class #id
## Oscope
<img src="../Figures/oscope.png" alt="Oscope algorithm" height="450" width="800">

Leng *et al.* (Nature Methods 2015)

--- .class #id
## Wanderlust
<img src="../Figures/wanderlust.png" alt="Wanderlust algorithm" height="500" width="500">

Bendall *et al.* (Cell 2014)

--- .class #id
## Gaussian processes
- Priors over functions, $f(x) \sim \mathcal{GP}(\mu, \Sigma)$
- Typically $x \in \mathbb{R}$ but can be applied to any domain
- Natural non-linear extension of Bayesian linear regression
- Characterised by mean function $\mu(x)$ and covariance
   function $\Sigma(x_1, x_2)$
- Covariance function encodes smoothness
- Large choice of covariance functions that can capture typical prior beliefs
- Particular choices of covariance function correspond to other models,
   e.g. splines, neural networks
- Analytic posterior gives full Bayesian treatment with uncertainty estimates
- Inference of covariance structure and parameters possible
- Require $O(n^3)$ inversion of covariance matrices
- Low rank approximations exist

--- .class #id
## Squared exponential covariance
```{r seCov, opts.label="prior.fig"}
samples.l <- sample.from.prior(rbfCreate(length.scale=.5))
# samples.l <- sample.from.prior(n=7, rbfCreate(length.scale=2))
ggplot(samples.l, aes(x=x, y=y, group=sample)) + geom_line() + y.axis
```

$$
\Sigma(x_1, x_2) = \Sigma(r=|x_1 - x_2|) = \exp\bigg(-\frac{r^2}{2 l^2}\bigg)
$$

--- .class #id
## Periodic covariance
```{r periodic, opts.label="prior.fig"}
samples.l <- sample.from.prior(rbfCreate(length.scale=.5))
samples.l$distance <- "r"
periodic.l <- sample.from.prior(periodicRbfCreate(length.scale=.5, period=2))
periodic.l$distance <- "u(r)"
(ggplot(rbind(samples.l, periodic.l),
        aes(x=x, y=y, group=sample))
    + geom_line()
    + y.axis
    + facet_wrap(~ distance))
```

$$
u(r) = \frac{\omega}{2}\sin\bigg(\frac{\pi r}{\omega}\bigg), \qquad
\Sigma(r) = \exp\bigg(-\frac{r^2}{2l^2}\bigg)
$$

--- .class #id
## Analytic posterior
```{r analytic, opts.label="prior.fig"}
observed <- data.frame(
    x = (0:6)/2,
    y = 2 * (runif(n=7) - .5))
kernRBF <- rbfCreate(length.scale=.5)
samples.l <- sample.from.posterior(kernRBF, x=observed$x, y=observed$y)
(
    ggplot(samples.l)
    + geom_line(aes(x=x, y=y, group=sample))
    + geom_point(data=observed, aes_string(x="x", y="y"), size=5)
    + y.axis
)
```

$$
\Sigma(r) = \exp\bigg(-\frac{r^2}{2 l^2}\bigg)
$$

--- .class #id
## Gaussian noise
```{r GaussianNoise, opts.label="prior.fig"}
samples.l <- sample.from.posterior(kernRBF, eps=.2,
                                   x=observed$x, y=observed$y)
(
    ggplot(samples.l, aes(x=x, y=y))
    + geom_line(aes(group=sample))
    + geom_point(data=observed, size=5)
    + y.axis
)
```

$$
\Sigma(x_i, x_j) = \epsilon^2\delta_{i=j}
$$


--- .class #id
## Posterior representation
```{r posterior, opts.label="prior.fig"}
cov.post <- posterior.covariance(kernRBF, eps=.2, x=observed$x, y=observed$y)
post.df <- posterior.as.df(cov.post)
plot.posterior(post.df, data=observed)
```

Ribbon shows two standard deviations either side of posterior mean (95%
confidence interval)


--- .class #id
## Model
- Estimate pseudotime for each cell
- Infer smooth low-noise expression profiles with Gaussian processes
- Model biological and technical cell size effects

--- .class #id
## Stan code

--- .class #id
## Low-rank approximation

--- .class #id
## Inference
- Stan
  * Gradient based samplers: No-U-Turn Sampler (NUTS), Hamiltonian Monte Carlo (HMC)
  * Automatic Differentiation Variational Inference (ADVI)
- Hard to explore combinatorial posterior

--- .class #id
## Held out smoothness

--- .class #id
## Arabidopsis response to infection

--- &twocol
## Cell cycle in PC3 cells

*** =left
- Data from McDavid *et al.* (PLoS Comp Bio 2014)
- nCounter single cell profiling
- Prostate cancer cell line
- 361 cells
- Used 56/333 differentially expressed genes
- McDavid *et al.* categorized each cell as GO/G1, S or G2/M phase


*** =right
- Used periodic covariance function
- Used model that infers cell sizes
- Ran ADVI variational inference
- Compared peak estimates to CycleBase database
- Peak time estimate RMSEs 50% better than naive method

--- .class #id
## Cell cycle in PC3 cells
<img src="../Figures/McDavid-profiles.png" alt="Embeddr algorithm" height="500" width="1000">

--- .class #id
## Paracrine signalling

--- .class #id
## Conclusions
